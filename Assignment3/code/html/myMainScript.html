
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>myMainScript</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-03-03"><meta name="DC.source" content="myMainScript.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Assignment 3, CT Imaging</a></li><li><a href="#2">Question 1</a></li><li><a href="#3">Part (a)</a></li><li><a href="#4">Part (b)</a></li><li><a href="#5">Part (c)</a></li><li><a href="#7">Part (d)</a></li><li><a href="#9">Part (e)</a></li><li><a href="#10">Question 2</a></li><li><a href="#11">Verifying against Matlab implementations</a></li><li><a href="#12">Part (a)</a></li><li><a href="#14">Part (b)</a></li><li><a href="#16">Part (c)</a></li><li><a href="#18">Question 3</a></li><li><a href="#19">Part (a, b), Dataset myPhantom</a></li><li><a href="#20">Part (a, b), Dataset Chest</a></li></ul></div><h2 id="1">Assignment 3, CT Imaging</h2><pre>CS736: Medical Image Computing, IIT Bombay (Spring 2019)
Dhruv Shah and Ansh Khurana</pre><p>Code for all 3 questions has been combined in myMainScript.m</p><pre class="codeinput">warning(<span class="string">'off'</span>, <span class="string">'all'</span>);
clc; clear <span class="string">all</span>; close <span class="string">all</span>;
</pre><h2 id="2">Question 1</h2><pre class="codeinput">img = phantom(128);
</pre><h2 id="3">Part (a)</h2><p>myIntegration is implemented in myImplementation.m The integration is the lower Darboux sum over the pixel values on a given line specifed by (t, <img src="myMainScript_eq08288499342375314727.png" alt="$\theta$">). The parameter $\Delta$s is configurable and is chosen to be 1*pixel width.</p><p>We have used bilinear interpolation technique.</p><p>Justification: The smaller the value of $\Delta$s, the finer and smoother the radonTransform is. Lower value of $\Delta$s ensure more accurate reimann-integral approximation. However, very low value of $\Delta$s can lead to higher computational expenses due to large number of interpolation steps. Thus we have chose $\Delta$s as 0.5,1 and 3.</p><p>Bilinear interpolation produces better results than nearest neighbour interpolation technique. We did not use cubic interpolation technique to avoid the computational expenses.</p><h2 id="4">Part (b)</h2><p>Implementation of Radon transformation can be found in myRadonTrans.m</p><p>Instead of calling myIntegration over the different ranges of t and <img src="myMainScript_eq08288499342375314727.png" alt="$\theta$">, the computation has been vectorized. See part (c) for radonTrans calculated with different parameters.</p><h2 id="5">Part (c)</h2><p>Computation of Radon transform for different parameters:</p><pre class="codeinput">dt = 5;
dth = 5;

ds1 = 0.5;
ds2 = 1;
ds3 = 3;

t_range = -90:dt:90;
theta_range =  0:dth:175;

Rf1 = myRadonTrans(img, t_range, theta_range, ds1);
iptsetpref(<span class="string">'ImshowAxesVisible'</span>,<span class="string">'on'</span>)

figure(<span class="string">'Position'</span>, [50, 100, 1200, 400]);
subplot(1,3, 1), imshow(Rf1, [],<span class="string">'Ydata'</span>, t_range, <span class="string">'Xdata'</span>, theta_range, <span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>)
xlabel(<span class="string">'\theta (degrees)'</span>)
ylabel(<span class="string">'t'</span>)
title(<span class="string">"Radon transform \Delta\theta = 5, \Deltat = 5, \Deltas = 0.5"</span>);
colormap(gca,hot), colorbar

Rf2 = myRadonTrans(img, t_range, theta_range, ds2);
iptsetpref(<span class="string">'ImshowAxesVisible'</span>,<span class="string">'on'</span>)

subplot(1,3, 2), imshow(Rf2, [],<span class="string">'Ydata'</span>, t_range, <span class="string">'Xdata'</span>, theta_range, <span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>)
xlabel(<span class="string">'\theta (degrees)'</span>)
ylabel(<span class="string">'t'</span>)
title(<span class="string">"Radon transform \Delta\theta = 5, \Deltat = 5, \Deltas = 1"</span>);
colormap(gca,hot), colorbar


Rf3 = myRadonTrans(img, t_range, theta_range, ds3);
iptsetpref(<span class="string">'ImshowAxesVisible'</span>,<span class="string">'on'</span>)

subplot(1,3,3), imshow(Rf3, [],<span class="string">'Ydata'</span>, t_range, <span class="string">'Xdata'</span>, theta_range, <span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>)
xlabel(<span class="string">'\theta (degrees)'</span>)
ylabel(<span class="string">'t'</span>)
title(<span class="string">"Radon transform \Delta\theta = 5, \Deltat = 5, \Deltas = 3"</span>);
colormap(gca,hot), colorbar
fig = gcf;
save(<span class="string">'../results/1c.mat'</span>, <span class="string">'fig'</span>, <span class="string">'-mat'</span>);
<span class="comment">% The plots for values at theta = 0 and theta  = 90</span>
figure(<span class="string">'Position'</span>, [50, 50, 1200, 600]);

subplot(1, 2, 1), plot(Rf1(:, 1)');
title(<span class="string">"\theta=0\degree"</span>);
xticklabels([]);
xlabel(<span class="string">" -90 &lt;= t &lt;= 90 (\Deltat = 5)"</span>)
subplot(1, 2, 2), plot(Rf1(:, 19)');
title(<span class="string">"\theta = 90\degrees"</span>)
xticklabels([]);
xlabel(<span class="string">" -90 &lt;= t &lt;= 90 (\Deltat = 5)"</span>)
sgtitle(<span class="string">"Plot for radon transform values (\Deltas=0.5)"</span>);
fig = gcf;
save(<span class="string">'../results/1c(1).mat'</span>, <span class="string">'fig'</span>, <span class="string">'-mat'</span>);
figure(<span class="string">'Position'</span>, [50, 50, 1200, 600]);

subplot(1, 2, 1), plot(Rf2(:, 1)');
title(<span class="string">"\theta = 0\degree"</span>);
xticklabels([]);
xlabel(<span class="string">" -90 &lt;= t &lt;= 90 (\Deltat = 5)"</span>)
subplot(1, 2, 2), plot(Rf2(:, 19)');
title(<span class="string">"\theta = 90\degrees"</span>)
xticklabels([]);
xlabel(<span class="string">" -90 &lt;= t &lt;= 90 (\Deltat = 5)"</span>)
sgtitle(<span class="string">"Plot for radon transform values (\Deltas=1)"</span>);


fig = gcf;
save(<span class="string">'../results/1c(2).mat'</span>, <span class="string">'fig'</span>, <span class="string">'-mat'</span>);
figure(<span class="string">'Position'</span>, [50, 50, 1200, 600]);

subplot(1, 2, 1), plot(Rf3(:, 1)');
title(<span class="string">"\theta = 0 \degree"</span>);
xticklabels([]);
xlabel(<span class="string">" -90 &lt;= t &lt;= 90 (\Deltat = 5)"</span>)
subplot(1, 2, 2), plot(Rf3(:, 19)');
title(<span class="string">"\theta = 90\degrees"</span>)
xticklabels([]);
xlabel(<span class="string">" -90 &lt;= t &lt;= 90 (\Deltat = 5)"</span>)
sgtitle(<span class="string">"Plot for radon transform values (\Deltas=3)"</span>);

fig = gcf;
save(<span class="string">'../results/1c(3).mat'</span>, <span class="string">'fig'</span>, <span class="string">'-mat'</span>);
</pre><img vspace="5" hspace="5" src="myMainScript_01.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_02.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_03.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_04.png" alt=""> <p>With lower value of $\Delta$s both the image and 1-D plots are smoother. This is because lower step size ensures finer and more accurate riemann integrals. Thus variation is smoother. With large $\Delta$s the approximation is crude and the variation is rough.</p><p>Also one observes that values 0 degree 1-D plots are smoother than 90 degrees 1-D plot. This is because of greater variations along horizontal lines because of the oval patterns in the image which stretch more along the Y direction than the X.</p><h2 id="7">Part (d)</h2><p>Comparing different values of <img src="myMainScript_eq04220687870110611234.png" alt="$\Delta\theta$"> and $\Delta$t:</p><pre class="codeinput">dt = 1;
dth = 1;
t_range = -90:dt:90;
theta_range = 0:dth:175;
Rf11 = myRadonTrans(img, t_range, theta_range, 1);

figure(<span class="string">'Position'</span>, [50, 100, 1200, 400]);
subplot(1,3, 1), imshow(Rf11, [],<span class="string">'Ydata'</span>, t_range, <span class="string">'Xdata'</span>, theta_range, <span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>)
xlabel(<span class="string">'\theta (degrees)'</span>)
ylabel(<span class="string">'t'</span>)
title(<span class="string">"Radon transform \Delta\theta = 1, \Deltat = 1, \Deltas = 1"</span>);
colormap(gca,hot), colorbar

dt = 3;
dth = 3;
t_range = -90:dt:90;
theta_range = 0:dth:175;
Rf33 = myRadonTrans(img, t_range, theta_range, 1);
iptsetpref(<span class="string">'ImshowAxesVisible'</span>,<span class="string">'on'</span>)

subplot(1,3, 2), imshow(Rf33, [],<span class="string">'Ydata'</span>, t_range, <span class="string">'Xdata'</span>, theta_range, <span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>)
xlabel(<span class="string">'\theta (degrees)'</span>)
ylabel(<span class="string">'t'</span>)
title(<span class="string">"Radon transform \Delta\theta = 3, \Deltat = 3, \Deltas = 1"</span>);
colormap(gca,hot), colorbar



dt = 5;
dth = 5;
t_range = -90:dt:90;
theta_range = 0:dth:175;
Rf55 = myRadonTrans(img, t_range, theta_range, 1);
iptsetpref(<span class="string">'ImshowAxesVisible'</span>,<span class="string">'on'</span>)

subplot(1,3,3), imshow(Rf55, [],<span class="string">'Ydata'</span>, t_range, <span class="string">'Xdata'</span>, theta_range, <span class="string">'InitialMagnification'</span>,<span class="string">'fit'</span>);
xlabel(<span class="string">'\theta (degrees)'</span>);
ylabel(<span class="string">'t'</span>);
title(<span class="string">"Radon transform \Delta\theta = 5, \Deltat = 5, \Deltas = 1"</span>);
colormap(gca,hot), colorbar;

sgtitle(<span class="string">"Radon transform for different values of \Deltat and \Delta\theta"</span>);

fig = gcf;
save(<span class="string">'../results/1d.mat'</span>, <span class="string">'fig'</span>, <span class="string">'-mat'</span>);
</pre><img vspace="5" hspace="5" src="myMainScript_05.png" alt=""> <p>As we can observe, the smaller are the values of \Deltat and \Delta\theta, the finer and smoother the Radon transformation is. This promotes the usage of smaller \Deltat and \Delta\theta to get more accurate results. This ofcourse assumes that the CT scanner is using a parallel beam of rays and filtered back-projection for scanning. The trade off of decreasing \Deltat and \Delta\theta is that one has requires scanning data accorss more lines which is practically not the case. This also requires a larger computational effort along with higher exposure to radiation. \Delta t = 1 and \Delta \theta = 1 seems to be a good choice.</p><h2 id="9">Part (e)</h2><pre>For a N*N image, we would like to have approximately O(N*N) projections to
reconstruct the image. A suitable choice for this gives \Deltat = 1 and
\Delta\theta = 1. Upon increasing the values of \Deltat and \Delta\Theta
we are loosing information to reconstruct the image while decreasing the
value further could lead to increase in computational effort and higher
exposure times.</pre><p>Effect of $\Delta$s &gt;&gt; 1 and $\Delta$s &lt;&lt; 1 (pixel-width)</p><p>$Delta$s decides the accuracy of our riemann integral approximation. Very large values of \Delta s cause inaccurate approximations of integral while very low values are also not useful since this causes wastage of computational effort as pixel intensity values are on a discrete grid separated by 1 pixel-width. Lower \Delta s requires large number of interpolations and does not improve much upon the integral.</p><h2 id="10">Question 2</h2><pre class="codeinput">clear <span class="string">all</span>;
iptsetpref(<span class="string">'ImshowAxesVisible'</span>,<span class="string">'off'</span>)


imsize = 256;
img = phantom(imsize);
theta = [0:3:177];

imrad = radon(img, theta);

imdec_BP = iradon(imrad, theta, <span class="string">'linear'</span>, <span class="string">'None'</span>, 1, imsize);
<span class="comment">% imagesc(imdec_BP)</span>

modes = {<span class="string">'Ram-Lak'</span>, <span class="string">'Cosine'</span>, <span class="string">'Shepp-Logan'</span>};
</pre><h2 id="11">Verifying against Matlab implementations</h2><pre class="codeinput">i = 1;
<span class="keyword">for</span> filt_type = modes
    imfilt = myFilter(imrad, char(filt_type), 1);
    imdec_ours = iradon(imfilt, theta, <span class="string">'linear'</span>, <span class="string">'None'</span>, 1, imsize);
    imdec_matlab = iradon(imrad, theta, <span class="string">'linear'</span>, char(filt_type), 1, imsize);
    figure;
    subplot(1, 2, 1); imagesc(imdec_ours); colorbar;
    title(strcat(char(filt_type), <span class="string">'(Ours)'</span>));
    subplot(1, 2, 2); imagesc(imdec_matlab); colorbar;
    title(strcat(char(filt_type), <span class="string">'(Matlab)'</span>));

    fig = gcf;
    save(strcat(<span class="string">'../results/2('</span>, num2str(i), <span class="string">').mat'</span>), <span class="string">'fig'</span>, <span class="string">'-mat'</span>);
    i = i+1;
<span class="keyword">end</span>
i = 1;
</pre><img vspace="5" hspace="5" src="myMainScript_06.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_07.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_08.png" alt=""> <h2 id="12">Part (a)</h2><pre class="codeinput">figure(<span class="string">'Position'</span>, [100, 100, 1000, 400]);
subplot(1, 2, 1); imagesc(img);
title(<span class="string">'Original'</span>);
subplot(1, 2, 2); imagesc(iradon(imrad, theta, <span class="string">'linear'</span>, <span class="string">'None'</span>, 1, imsize));
title(<span class="string">'Unfiltered Back Projection'</span>)
 fig = gcf;
 save(<span class="string">'../results/2a.mat'</span>, <span class="string">'fig'</span>, <span class="string">'-mat'</span>);
<span class="keyword">for</span> filt_type = modes
    imfilt1 = myFilter(imrad, char(filt_type), 1);
    imdec_ours1 = iradon(imfilt1, theta, <span class="string">'linear'</span>, <span class="string">'None'</span>, 1, imsize);
    imfilt2 = myFilter(imrad, char(filt_type), 0.5);
    imdec_ours2 = iradon(imfilt2, theta, <span class="string">'linear'</span>, <span class="string">'None'</span>, 1, imsize);
    figure(<span class="string">'Position'</span>, [100, 100, 1000, 400]);
    subplot(1, 2, 1); imagesc(imdec_ours1);
    title(strcat(char(filt_type), <span class="string">'(L = w_{max})'</span>));
    subplot(1, 2, 2); imagesc(imdec_ours2);
    title(strcat(char(filt_type), <span class="string">'(L = w_{max} / 2)'</span>));

    fig = gcf;
    save(strcat(<span class="string">'../results/2a('</span>, num2str(i), <span class="string">').mat'</span>), <span class="string">'fig'</span>, <span class="string">'-mat'</span>);
    i = i+1;
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="myMainScript_09.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_10.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_11.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_12.png" alt=""> <p>With lower frequency (w_max/2) the images are slightly blurred as compared to w_max. This is because lower frequency means some high frequency part of the fourier transform are not present which leads to less sharp and blurred images.</p><p>Amongst the filters, Ram-Lak produces a sharper image around the boundary of the main oval. Cosine filter produces a less sharp, smoother image. This is because Ram-Lak cuts off high-frequency parts of the transform the least, while cosine performs maximum smoothing and blurring.</p><h2 id="14">Part (b)</h2><pre class="codeinput">g1 = fspecial(<span class="string">'gaussian'</span>, 11, 1);
g5 = fspecial(<span class="string">'gaussian'</span>, 51, 5);

img1 = conv2(img, g1, <span class="string">'same'</span>);
img5 = conv2(img, g5, <span class="string">'same'</span>);



imrad1 = radon(img1, theta);
imrad5 = radon(img5, theta);

<span class="comment">% 3 Different versions of the Shepp-Logan image</span>
figure(<span class="string">'Position'</span>, [50, 100, 1200, 400]);
subplot(1,3,1), imagesc(img);
title(<span class="string">"S_0"</span>);
subplot(1,3,2), imagesc(img1);
title(<span class="string">"S_1"</span>);
subplot(1,3,3), imagesc(img5);
title(<span class="string">"S_2"</span>);
sgtitle(<span class="string">"Three Different versions of the Shepp-Logan image"</span>);

fig = gcf;
save(<span class="string">'../results/2b(1).mat'</span>, <span class="string">'fig'</span>, <span class="string">'-mat'</span>);
imfilt = myFilter(imrad, <span class="string">'Ram-Lak'</span>, 1);
imfilt1 = myFilter(imrad1, <span class="string">'Ram-Lak'</span>, 1);
imfilt5 = myFilter(imrad5, <span class="string">'Ram-Lak'</span>, 1);

imdec = iradon(imfilt, theta, <span class="string">'linear'</span>, <span class="string">'None'</span>, 1, imsize);
imdec1 = iradon(imfilt1, theta, <span class="string">'linear'</span>, <span class="string">'None'</span>, 1, imsize);
imdec5 = iradon(imfilt5, theta, <span class="string">'linear'</span>, <span class="string">'None'</span>, 1, imsize);

rrmse_0 = rrmse(img, imdec);
rrmse_1 = rrmse(img1, imdec1);
rrmse_5 = rrmse(img5, imdec5);

figure(<span class="string">'Position'</span>, [50, 100, 1200, 400]);
subplot(1,3,1), imagesc(imdec);
title(strcat(<span class="string">"R_0, RRMSE(S_0, R_0) = "</span>, num2str(rrmse_0)));
subplot(1,3,2), imagesc(imdec1);
title(strcat(<span class="string">"R_1, RRMSE(S_1, R_1) = "</span>, num2str(rrmse_1)));
subplot(1,3,3), imagesc(imdec5);
title(strcat(<span class="string">"R_2, RRMSE(S_2, R_2) = "</span>, num2str(rrmse_5)));
sgtitle(<span class="string">"Filtered back projections for the three images"</span>);

fig = gcf;
save(<span class="string">'../results/2b(2).mat'</span>, <span class="string">'fig'</span>, <span class="string">'-mat'</span>);
</pre><img vspace="5" hspace="5" src="myMainScript_13.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_14.png" alt=""> <p>RRMSE decreases from (S_0, R_0) to (S_1, R_1) to (S_2, R_2). This is because the filtered back-projection is an approximated inverse of the original image. The resulting images from this operation have blurred out higher frequency components and thus sharp portions of the images are blurred out. Since S3 is already blurred the filtered back-projection does not cause significant loss in details. Thus RRMSE is lower.</p><h2 id="16">Part (c)</h2><pre class="codeinput">fft_n = 1024;
logger = zeros([fft_n/2, 3]);
<span class="keyword">for</span> i = 1:fft_n/2
    frac = i * 2 / fft_n;

    imfilt = myFilter(imrad, <span class="string">'Ram-Lak'</span>, frac);
    imfilt1 = myFilter(imrad1, <span class="string">'Ram-Lak'</span>, frac);
    imfilt5 = myFilter(imrad5, <span class="string">'Ram-Lak'</span>, frac);

    imdec = iradon(imfilt, theta, <span class="string">'linear'</span>, <span class="string">'None'</span>, 1, imsize);
    imdec1 = iradon(imfilt1, theta, <span class="string">'linear'</span>, <span class="string">'None'</span>, 1, imsize);
    imdec5 = iradon(imfilt5, theta, <span class="string">'linear'</span>, <span class="string">'None'</span>, 1, imsize);

    logger(i, 1) = rrmse(img, imdec);
    logger(i, 2) = rrmse(img1, imdec1);
    logger(i, 3) = rrmse(img5, imdec5);
<span class="keyword">end</span>
figure;
plot([2/fft_n:2/fft_n:1], logger, <span class="string">'LineWidth'</span>, 1.5);
legend(<span class="string">'Noiseless'</span>, <span class="string">'\sigma=1'</span>, <span class="string">'\sigma=5'</span>)
xlabel(<span class="string">'L / w_{max}'</span>);
ylabel(<span class="string">'RRMSE'</span>)
fig = gcf;
save(<span class="string">'../results/2c.mat'</span>, <span class="string">'fig'</span>, <span class="string">'-mat'</span>);
</pre><img vspace="5" hspace="5" src="myMainScript_15.png" alt=""> <p>Upon increasing the frequency the RRMSE decreases which is expected since higher frequency transform is more accurate and consists of more information. Higher frequency preserves more sharpness/detail.</p><h2 id="18">Question 3</h2><pre class="codeinput">clear <span class="string">all</span>;
<span class="comment">% We arbitrarily choose the Shepp-Logan filter for FBP.</span>
filt_type = <span class="string">'Shepp-Logan'</span>;
t0_cand = [1:180];
theta_range = 150;
logger = zeros(numel(t0_cand), 2);
</pre><h2 id="19">Part (a, b), Dataset myPhantom</h2><pre class="codeinput">load(<span class="string">'../data/myPhantom.mat'</span>);
img = imageAC;
imsize = size(img, 1); <span class="comment">% Assumed square</span>

<span class="keyword">for</span> t0 = t0_cand
    thetas = mod([t0:t0+theta_range], 180);
    imrad = radon(img, thetas);
    imfilt = myFilter(imrad, filt_type, 1);
    imdec = iradon(imfilt, thetas, <span class="string">'linear'</span>, <span class="string">'None'</span>, 1, imsize);
    logger(t0, 1) = rrmse(img, imdec);
<span class="keyword">end</span>

[minval_phantom, min_t0_phantom] = min(logger(:, 1)); <span class="comment">% min_t0 = 105;</span>
figure, plot(logger(:, 1));
xlabel(<span class="string">'\theta_0 Candidates'</span>)
ylabel(<span class="string">'RRMSE'</span>)

fig = gcf;
save(<span class="string">'../results/3a(1).mat'</span>, <span class="string">'fig'</span>, <span class="string">'-mat'</span>);

thetas = mod([min_t0_phantom:min_t0_phantom+theta_range], 180);
imrad = radon(img, thetas);
imfilt = myFilter(imrad, filt_type, 1);
imdec = iradon(imfilt, thetas, <span class="string">'linear'</span>, <span class="string">'None'</span>, 1, imsize);

figure, imagesc(imdec);
title(strcat(<span class="string">'Best Reconstruction of myPhantom with \theta_0='</span>, num2str(min_t0_phantom), <span class="string">' RRMSE='</span>, num2str(minval_phantom)));

fig = gcf;
save(<span class="string">'../results/3b(1).mat'</span>, <span class="string">'fig'</span>, <span class="string">'-mat'</span>);
</pre><img vspace="5" hspace="5" src="myMainScript_16.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_17.png" alt=""> <h2 id="20">Part (a, b), Dataset Chest</h2><pre class="codeinput">load(<span class="string">'../data/CT_Chest.mat'</span>);
img = imageAC;
imsize = size(img, 1); <span class="comment">% Assumed square</span>

<span class="keyword">for</span> t0 = t0_cand
    thetas = mod([t0:t0+theta_range], 180);
    imrad = radon(img, thetas);
    imfilt = myFilter(imrad, filt_type, 1);
    imdec = iradon(imfilt, thetas, <span class="string">'linear'</span>, <span class="string">'None'</span>, 1, imsize);
    logger(t0, 2) = rrmse(img, imdec);
<span class="keyword">end</span>

[minval_chest, min_t0_chest] = min(logger(:, 2)); <span class="comment">% min_t0 = 35;</span>
figure, plot(logger(:, 2));
xlabel(<span class="string">'\theta_0 Candidates'</span>)
ylabel(<span class="string">'RRMSE'</span>)

fig = gcf;
save(<span class="string">'../results/3a(2).mat'</span>, <span class="string">'fig'</span>, <span class="string">'-mat'</span>);
thetas = mod([min_t0_chest:min_t0_chest+theta_range], 180);
imrad = radon(img, thetas);
imfilt = myFilter(imrad, filt_type, 1);
imdec = iradon(imfilt, thetas, <span class="string">'linear'</span>, <span class="string">'None'</span>, 1, imsize);

figure, imagesc(imdec);
title(strcat(<span class="string">'Best Reconstruction of CT_Chest with \theta_0='</span>, num2str(min_t0_chest), <span class="string">' RRMSE='</span>, num2str(minval_chest)));

fig = gcf;
save(<span class="string">'../results/3b(2).mat'</span>, <span class="string">'fig'</span>, <span class="string">'-mat'</span>);
</pre><img vspace="5" hspace="5" src="myMainScript_18.png" alt=""> <img vspace="5" hspace="5" src="myMainScript_19.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Assignment 3, CT Imaging
%  CS736: Medical Image Computing, IIT Bombay (Spring 2019)
%  Dhruv Shah and Ansh Khurana
%
% Code for all 3 questions has been combined in myMainScript.m
% 

warning('off', 'all');
clc; clear all; close all;
%% Question 1 
img = phantom(128);
%% Part (a)
% myIntegration is implemented in myImplementation.m
% The integration is the lower Darboux sum over the pixel values on a given
% line specifed by (t, $\theta$). The parameter $\Delta$s is configurable 
% and is chosen to be 1*pixel width.
%
% We have used bilinear interpolation technique.
%
% Justification:
% The smaller the value of $\Delta$s, the finer and smoother the
% radonTransform is. Lower value of $\Delta$s ensure more accurate
% reimann-integral approximation. However, very low value of $\Delta$s can
% lead to higher computational expenses due to large number of
% interpolation steps. Thus we have chose $\Delta$s as 0.5,1 and 3.
%
% Bilinear interpolation produces better results than nearest neighbour
% interpolation technique. We did not use cubic interpolation technique to
% avoid the computational expenses.


%% Part (b)
% Implementation of Radon transformation can be found in myRadonTrans.m
% 
% Instead of calling myIntegration over the different ranges of t and
% $\theta$, the computation has been vectorized.
% See part (c) for radonTrans calculated with different parameters.

%% Part (c) 
% Computation of Radon transform for different parameters:

dt = 5;
dth = 5; 

ds1 = 0.5;
ds2 = 1;
ds3 = 3;

t_range = -90:dt:90;
theta_range =  0:dth:175;

Rf1 = myRadonTrans(img, t_range, theta_range, ds1);
iptsetpref('ImshowAxesVisible','on')

figure('Position', [50, 100, 1200, 400]);
subplot(1,3, 1), imshow(Rf1, [],'Ydata', t_range, 'Xdata', theta_range, 'InitialMagnification','fit')
xlabel('\theta (degrees)')
ylabel('t')
title("Radon transform \Delta\theta = 5, \Deltat = 5, \Deltas = 0.5");
colormap(gca,hot), colorbar

Rf2 = myRadonTrans(img, t_range, theta_range, ds2);
iptsetpref('ImshowAxesVisible','on')

subplot(1,3, 2), imshow(Rf2, [],'Ydata', t_range, 'Xdata', theta_range, 'InitialMagnification','fit')
xlabel('\theta (degrees)')
ylabel('t')
title("Radon transform \Delta\theta = 5, \Deltat = 5, \Deltas = 1");
colormap(gca,hot), colorbar


Rf3 = myRadonTrans(img, t_range, theta_range, ds3);
iptsetpref('ImshowAxesVisible','on')

subplot(1,3,3), imshow(Rf3, [],'Ydata', t_range, 'Xdata', theta_range, 'InitialMagnification','fit')
xlabel('\theta (degrees)')
ylabel('t')
title("Radon transform \Delta\theta = 5, \Deltat = 5, \Deltas = 3");
colormap(gca,hot), colorbar
fig = gcf;
save('../results/1c.mat', 'fig', '-mat');
% The plots for values at theta = 0 and theta  = 90
figure('Position', [50, 50, 1200, 600]);

subplot(1, 2, 1), plot(Rf1(:, 1)');
title("\theta=0\degree");
xticklabels([]);
xlabel(" -90 <= t <= 90 (\Deltat = 5)")
subplot(1, 2, 2), plot(Rf1(:, 19)');
title("\theta = 90\degrees")
xticklabels([]);
xlabel(" -90 <= t <= 90 (\Deltat = 5)")
sgtitle("Plot for radon transform values (\Deltas=0.5)");
fig = gcf;
save('../results/1c(1).mat', 'fig', '-mat');
figure('Position', [50, 50, 1200, 600]);

subplot(1, 2, 1), plot(Rf2(:, 1)');
title("\theta = 0\degree");
xticklabels([]);
xlabel(" -90 <= t <= 90 (\Deltat = 5)")
subplot(1, 2, 2), plot(Rf2(:, 19)');
title("\theta = 90\degrees")
xticklabels([]);
xlabel(" -90 <= t <= 90 (\Deltat = 5)")
sgtitle("Plot for radon transform values (\Deltas=1)");


fig = gcf;
save('../results/1c(2).mat', 'fig', '-mat');
figure('Position', [50, 50, 1200, 600]);

subplot(1, 2, 1), plot(Rf3(:, 1)');
title("\theta = 0 \degree");
xticklabels([]);
xlabel(" -90 <= t <= 90 (\Deltat = 5)")
subplot(1, 2, 2), plot(Rf3(:, 19)');
title("\theta = 90\degrees")
xticklabels([]);
xlabel(" -90 <= t <= 90 (\Deltat = 5)")
sgtitle("Plot for radon transform values (\Deltas=3)");

fig = gcf;
save('../results/1c(3).mat', 'fig', '-mat');
%%
% With lower value of $\Delta$s both the image and 1-D plots are smoother.
% This is because lower step size ensures finer and more accurate riemann
% integrals. Thus variation is smoother. With large $\Delta$s the
% approximation is crude and the variation is rough.
%
% Also one observes that values 0 degree 1-D plots are smoother than 90
% degrees 1-D plot. This is because of greater variations along horizontal
% lines because of the oval patterns in the image which stretch more along
% the Y direction than the X.

%% Part (d)
% Comparing different values of $\Delta\theta$ and $\Delta$t:
dt = 1;
dth = 1;
t_range = -90:dt:90;
theta_range = 0:dth:175;
Rf11 = myRadonTrans(img, t_range, theta_range, 1);

figure('Position', [50, 100, 1200, 400]);
subplot(1,3, 1), imshow(Rf11, [],'Ydata', t_range, 'Xdata', theta_range, 'InitialMagnification','fit')
xlabel('\theta (degrees)')
ylabel('t')
title("Radon transform \Delta\theta = 1, \Deltat = 1, \Deltas = 1");
colormap(gca,hot), colorbar

dt = 3;
dth = 3;
t_range = -90:dt:90;
theta_range = 0:dth:175;
Rf33 = myRadonTrans(img, t_range, theta_range, 1);
iptsetpref('ImshowAxesVisible','on')

subplot(1,3, 2), imshow(Rf33, [],'Ydata', t_range, 'Xdata', theta_range, 'InitialMagnification','fit')
xlabel('\theta (degrees)')
ylabel('t')
title("Radon transform \Delta\theta = 3, \Deltat = 3, \Deltas = 1");
colormap(gca,hot), colorbar



dt = 5;
dth = 5;
t_range = -90:dt:90;
theta_range = 0:dth:175;
Rf55 = myRadonTrans(img, t_range, theta_range, 1);
iptsetpref('ImshowAxesVisible','on')

subplot(1,3,3), imshow(Rf55, [],'Ydata', t_range, 'Xdata', theta_range, 'InitialMagnification','fit');
xlabel('\theta (degrees)');
ylabel('t');
title("Radon transform \Delta\theta = 5, \Deltat = 5, \Deltas = 1");
colormap(gca,hot), colorbar;

sgtitle("Radon transform for different values of \Deltat and \Delta\theta");

fig = gcf;
save('../results/1d.mat', 'fig', '-mat');
%%
% As we can observe, the smaller are the values of \Deltat and
% \Delta\theta, the finer and smoother the Radon transformation is. This
% promotes the usage of smaller \Deltat and \Delta\theta to get more
% accurate results. This ofcourse assumes that the CT scanner is using a
% parallel beam of rays and filtered back-projection for scanning. The
% trade off of decreasing \Deltat and \Delta\theta is that one has requires
% scanning data accorss more lines which is practically not the case. This
% also requires a larger computational effort along with higher exposure to
% radiation. \Delta t = 1 and \Delta \theta = 1 seems to be a good choice.

%% Part (e)
%
%  For a N*N image, we would like to have approximately O(N*N) projections to
%  reconstruct the image. A suitable choice for this gives \Deltat = 1 and
%  \Delta\theta = 1. Upon increasing the values of \Deltat and \Delta\Theta
%  we are loosing information to reconstruct the image while decreasing the
%  value further could lead to increase in computational effort and higher
%  exposure times.
%
% Effect of $\Delta$s >> 1 and $\Delta$s << 1 (pixel-width)
%
% $Delta$s decides the accuracy of our riemann integral approximation. Very
% large values of \Delta s cause inaccurate approximations of integral
% while very low values are also not useful since this causes wastage of
% computational effort as pixel intensity values are on a discrete grid
% separated by 1 pixel-width. Lower \Delta s requires large number of
% interpolations and does not improve much upon the integral.


%% Question 2
clear all; 
iptsetpref('ImshowAxesVisible','off')


imsize = 256;
img = phantom(imsize);
theta = [0:3:177];

imrad = radon(img, theta);

imdec_BP = iradon(imrad, theta, 'linear', 'None', 1, imsize);
% imagesc(imdec_BP)

modes = {'Ram-Lak', 'Cosine', 'Shepp-Logan'};

%% Verifying against Matlab implementations
i = 1;
for filt_type = modes
    imfilt = myFilter(imrad, char(filt_type), 1);
    imdec_ours = iradon(imfilt, theta, 'linear', 'None', 1, imsize);
    imdec_matlab = iradon(imrad, theta, 'linear', char(filt_type), 1, imsize);
    figure;
    subplot(1, 2, 1); imagesc(imdec_ours); colorbar;
    title(strcat(char(filt_type), '(Ours)'));
    subplot(1, 2, 2); imagesc(imdec_matlab); colorbar;
    title(strcat(char(filt_type), '(Matlab)'));
    
    fig = gcf;  
    save(strcat('../results/2(', num2str(i), ').mat'), 'fig', '-mat');
    i = i+1;
end
i = 1; 
%% Part (a)

figure('Position', [100, 100, 1000, 400]);
subplot(1, 2, 1); imagesc(img);
title('Original');
subplot(1, 2, 2); imagesc(iradon(imrad, theta, 'linear', 'None', 1, imsize));
title('Unfiltered Back Projection')
 fig = gcf;
 save('../results/2a.mat', 'fig', '-mat');
for filt_type = modes
    imfilt1 = myFilter(imrad, char(filt_type), 1);
    imdec_ours1 = iradon(imfilt1, theta, 'linear', 'None', 1, imsize);
    imfilt2 = myFilter(imrad, char(filt_type), 0.5);
    imdec_ours2 = iradon(imfilt2, theta, 'linear', 'None', 1, imsize);
    figure('Position', [100, 100, 1000, 400]);
    subplot(1, 2, 1); imagesc(imdec_ours1);
    title(strcat(char(filt_type), '(L = w_{max})'));
    subplot(1, 2, 2); imagesc(imdec_ours2);
    title(strcat(char(filt_type), '(L = w_{max} / 2)'));

    fig = gcf;
    save(strcat('../results/2a(', num2str(i), ').mat'), 'fig', '-mat');
    i = i+1;
end

%%
% With lower frequency (w_max/2) the images are slightly blurred as
% compared to w_max. This is because lower frequency means some high
% frequency part of the fourier transform are not present which leads to
% less sharp and blurred images.
%
% Amongst the filters, Ram-Lak produces a sharper image around the boundary
% of the main oval. Cosine filter produces a less sharp, smoother image.
% This is because Ram-Lak cuts off high-frequency parts of the transform
% the least, while cosine performs maximum smoothing and blurring.
%% Part (b)

g1 = fspecial('gaussian', 11, 1);
g5 = fspecial('gaussian', 51, 5);

img1 = conv2(img, g1, 'same');
img5 = conv2(img, g5, 'same');



imrad1 = radon(img1, theta);
imrad5 = radon(img5, theta);

% 3 Different versions of the Shepp-Logan image
figure('Position', [50, 100, 1200, 400]);
subplot(1,3,1), imagesc(img);
title("S_0");
subplot(1,3,2), imagesc(img1);
title("S_1");
subplot(1,3,3), imagesc(img5);
title("S_2");
sgtitle("Three Different versions of the Shepp-Logan image");

fig = gcf;
save('../results/2b(1).mat', 'fig', '-mat');
imfilt = myFilter(imrad, 'Ram-Lak', 1);
imfilt1 = myFilter(imrad1, 'Ram-Lak', 1);
imfilt5 = myFilter(imrad5, 'Ram-Lak', 1);

imdec = iradon(imfilt, theta, 'linear', 'None', 1, imsize);
imdec1 = iradon(imfilt1, theta, 'linear', 'None', 1, imsize);
imdec5 = iradon(imfilt5, theta, 'linear', 'None', 1, imsize);

rrmse_0 = rrmse(img, imdec);
rrmse_1 = rrmse(img1, imdec1);
rrmse_5 = rrmse(img5, imdec5);

figure('Position', [50, 100, 1200, 400]);
subplot(1,3,1), imagesc(imdec);
title(strcat("R_0, RRMSE(S_0, R_0) = ", num2str(rrmse_0)));
subplot(1,3,2), imagesc(imdec1);
title(strcat("R_1, RRMSE(S_1, R_1) = ", num2str(rrmse_1)));
subplot(1,3,3), imagesc(imdec5);
title(strcat("R_2, RRMSE(S_2, R_2) = ", num2str(rrmse_5)));
sgtitle("Filtered back projections for the three images");

fig = gcf;
save('../results/2b(2).mat', 'fig', '-mat');
%%
% RRMSE decreases from (S_0, R_0) to (S_1, R_1) to (S_2, R_2). This is because
% the filtered back-projection is an approximated inverse of the original
% image. The resulting images from this operation have blurred out higher
% frequency components and thus sharp portions of the images are blurred
% out. Since S3 is already blurred the filtered back-projection does not
% cause significant loss in details. Thus RRMSE is lower.

%% Part (c)

fft_n = 1024;
logger = zeros([fft_n/2, 3]);
for i = 1:fft_n/2
    frac = i * 2 / fft_n;
    
    imfilt = myFilter(imrad, 'Ram-Lak', frac);
    imfilt1 = myFilter(imrad1, 'Ram-Lak', frac);
    imfilt5 = myFilter(imrad5, 'Ram-Lak', frac);

    imdec = iradon(imfilt, theta, 'linear', 'None', 1, imsize);
    imdec1 = iradon(imfilt1, theta, 'linear', 'None', 1, imsize);
    imdec5 = iradon(imfilt5, theta, 'linear', 'None', 1, imsize);

    logger(i, 1) = rrmse(img, imdec);
    logger(i, 2) = rrmse(img1, imdec1);
    logger(i, 3) = rrmse(img5, imdec5);
end
figure;
plot([2/fft_n:2/fft_n:1], logger, 'LineWidth', 1.5);
legend('Noiseless', '\sigma=1', '\sigma=5')
xlabel('L / w_{max}');
ylabel('RRMSE')
fig = gcf;
save('../results/2c.mat', 'fig', '-mat');
%%
% Upon increasing the frequency the RRMSE decreases which is expected since
% higher frequency transform is more accurate and consists of more
% information. Higher frequency preserves more sharpness/detail.

%% Question 3
clear all; 
% We arbitrarily choose the Shepp-Logan filter for FBP.
filt_type = 'Shepp-Logan';
t0_cand = [1:180];
theta_range = 150;
logger = zeros(numel(t0_cand), 2);

%% Part (a, b), Dataset myPhantom

load('../data/myPhantom.mat');
img = imageAC;
imsize = size(img, 1); % Assumed square

for t0 = t0_cand
    thetas = mod([t0:t0+theta_range], 180);
    imrad = radon(img, thetas);
    imfilt = myFilter(imrad, filt_type, 1);
    imdec = iradon(imfilt, thetas, 'linear', 'None', 1, imsize);
    logger(t0, 1) = rrmse(img, imdec);
end

[minval_phantom, min_t0_phantom] = min(logger(:, 1)); % min_t0 = 105;
figure, plot(logger(:, 1));
xlabel('\theta_0 Candidates')
ylabel('RRMSE')

fig = gcf;
save('../results/3a(1).mat', 'fig', '-mat');

thetas = mod([min_t0_phantom:min_t0_phantom+theta_range], 180);
imrad = radon(img, thetas);
imfilt = myFilter(imrad, filt_type, 1);
imdec = iradon(imfilt, thetas, 'linear', 'None', 1, imsize);

figure, imagesc(imdec);
title(strcat('Best Reconstruction of myPhantom with \theta_0=', num2str(min_t0_phantom), ' RRMSE=', num2str(minval_phantom)));

fig = gcf;
save('../results/3b(1).mat', 'fig', '-mat');
%% Part (a, b), Dataset Chest

load('../data/CT_Chest.mat');
img = imageAC;
imsize = size(img, 1); % Assumed square

for t0 = t0_cand
    thetas = mod([t0:t0+theta_range], 180);
    imrad = radon(img, thetas);
    imfilt = myFilter(imrad, filt_type, 1);
    imdec = iradon(imfilt, thetas, 'linear', 'None', 1, imsize);
    logger(t0, 2) = rrmse(img, imdec);
end

[minval_chest, min_t0_chest] = min(logger(:, 2)); % min_t0 = 35;
figure, plot(logger(:, 2));
xlabel('\theta_0 Candidates')
ylabel('RRMSE')

fig = gcf;
save('../results/3a(2).mat', 'fig', '-mat');
thetas = mod([min_t0_chest:min_t0_chest+theta_range], 180);
imrad = radon(img, thetas);
imfilt = myFilter(imrad, filt_type, 1);
imdec = iradon(imfilt, thetas, 'linear', 'None', 1, imsize);

figure, imagesc(imdec);
title(strcat('Best Reconstruction of CT_Chest with \theta_0=', num2str(min_t0_chest), ' RRMSE=', num2str(minval_chest)));

fig = gcf;
save('../results/3b(2).mat', 'fig', '-mat');
##### SOURCE END #####
--></body></html>